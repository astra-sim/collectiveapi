# TEN Graph Visualizer for Chakra ET Files

## Introduction

This tool provides a **TEN-style communication timeline visualizer** built on top of **Chakra ET files**.  
It is designed to support **MSCCL** and **TACOS** collective algorithms and visualizes their communication structure in a **time-expanded network (TEN)** layout.

The visualizer operates on **`.et` files generated from MSCCL/TACOS XML descriptions**.  
The XML to ET conversion is performed using the script: `create_custom_allreduce_algorithm`.

This script converts collective algorithm XMLs into Chakra compatible ET traces. These ET files are then consumed by the visualizer to reconstruct logical communication ordering, dependencies, and message chunking across ranks.

The final output is an **interactive HTML visualization** that shows:
- Logical global communication rounds
- Rank-to-rank message flow
- Message chunking and ordering
- Dependency-constrained execution order

## ET File Assumptions

The visualizer assumes ET files that:

- Are generated by Chakra tooling
- Contain one ET file per rank (for example, `*.rank.et`)
- Encode communication semantics using:
  - `COMM_SEND_NODE`
  - `COMM_RECV_NODE`
- Include relevant attributes such as:
  - `local_time_step`
  - `tb_id`
  - `comm_src`, `comm_dst`
  - `depid`, `deps`
  - `chunk_offset`
  - `msg_chunk_cnt`


## Graph Construction

Graph construction proceeds in **two major phases**.


### 1. Rank Specific Step DAG Construction

Each ET file is parsed and indexed using the tuple: (rank, tb_id, local_time_step)


For every such step:
- All events belonging to the same `(rank, tb_id, local_time_step)` are grouped into a **step-node**
- A step-node may contain:
  - SEND events
  - RECV events
  - OTHER (non-communication) events

### Intra-Threadblock Ordering

Within a given `(rank, tb_id)`, step-nodes are connected in ascending `local_time_step` order.  
This preserves the natural program order within a threadblock.

### Explicit Dependency Edges

If dependency attributes are present and valid, edges of the form: `(depid, deps)` â†’ `(tb_id, local_time_step)` 
are added to the DAG. These edges ensure that Chakra dependency semantics are faithfully preserved in the graph.

The result of this phase is a **full per-rank DAG** containing both SEND and non-SEND steps.

### 2. Global SEND Timeline Assignment

Only **step-nodes that contain SEND events** participate in the global TEN timeline.

For each rank:

1. Steps are topologically sorted to respect all dependencies.

2. Each SEND step is assigned a sequential global time slot considering all threadblocks for a given rank, so the timeline is continuous with no gaps. In other words, each SEND step becomes a node in the TEN timeline.

3. Non-SEND steps propagate ordering constraints but do not take up a time slot themselves, ensuring that SENDs remain properly ordered.

This produces a compact global timeline representation with nodes named: `r<rank>:t<global_time>`. Multiple SENDs between the same `(src, dst)` pair at the same time step are supported via a `MultiDiGraph`.

## Visualization

The visualization is implemented using **Plotly** and rendered as a self-contained **interactive HTML file**.

### Layout

- **Columns** represent global time steps (`t = 0, 1, 2, ...`)
- **Rows** represent ranks (one row per rank)
- **Nodes** (`r<rank>:t<time>`) are drawn as square markers
- **Edges** are drawn as directed arrows representing communication

### Visual Features

- **Chunk bubbles** - Colored markers along communication edges, one per chunk with its ID.
- **Parallel edge offsetting** - Multiple edges between the same nodes are visually separated
- **Hover interaction** - Hovering over nodes, edges, or chunks highlights related elements
- **Dynamic sizing** - Figure dimensions scale with the number of ranks and time steps

## Output

Running the tool produces an HTML file: `TEN_graph.html`. The HTML file can be opened in a browser (Chrome, etc.) to see the visualized TEN graph.

**Note**:
The hovering feature requires the `hightlight_hover.js` file to be in the same directory as the TEN script.

## Usage

```bash
python3 ten_visualizer.py \
  --input_dir path/to/et_files \
  --html TEN_graph.html
```

Arguments

--input_dir
Directory containing Chakra .et files

--html
Output HTML file name

## Next Steps
1. **Incorporate physical topology**  
   Extend the visualization to reflect the underlying hardware layout (e.g., a 3D torus network), so communication paths are mapped to actual interconnects between ranks.

2. **Trace message chunks across time**  
   Visualize the path of each message chunk from its first SEND (time step 0) to the final RECV, showing how data moves through the network over time.

3. **Directly from Chakra Graph**  
   Dependency information is already encoded in the default Chakra graph. See if we can leverage this information wihtout having to add the step_id, etc. attributes. This will help us have a smaller Chakra file with less attributes. 




